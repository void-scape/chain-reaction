use std::f32::consts::PI;
use std::marker::PhantomData;
use std::time::Duration;

use crate::ball::{Ball, BallComponents, PaddleRestMult, PlayerBall};
use crate::big::BigPoints;
use crate::collectables::PointEvent;
use crate::state::{GameState, StateAppExt, remove_entities};
use crate::{Avian, Layer, cabinet};
use avian2d::prelude::PhysicsSet;
use avian2d::prelude::*;
use bevy::prelude::*;

use self::grid::FeatureGrid;

mod features;
pub mod grid;

pub use features::*;

pub struct FeaturePlugin;

impl Plugin for FeaturePlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(FeaturesPlugin)
            .add_reset((
                remove_entities::<With<Feature>>,
                remove_entities::<With<FeatureGrid>>,
            ))
            .add_event::<FeatureBonk>()
            .add_event::<BonksReload>()
            .add_systems(OnEnter(GameState::StartGame), spawn_feature_zone)
            .add_systems(Update, (grid::FeatureGrid::spawn_slots, debug_impulse))
            .add_systems(Avian, despawn_empty_bonks.before(PhysicsSet::Prepare))
            .add_observer(bonks)
            .add_observer(bonk_bounce)
            .add_observer(feature_bonk);
    }
}

#[allow(unused)]
#[derive(Event)]
pub struct FeatureBonk {
    pub feature: Entity,
    pub ball: Entity,
}

#[derive(Component)]
#[require(
    RigidBody::Kinematic,
    Collider::rectangle(cabinet::WIDTH / 1.5, cabinet::HEIGHT / 1.5),
    CollisionLayers::new(Layer::FeatureZone, Layer::Ball),
    CollisionEventsEnabled,
    Sensor,
    grid::FeatureGrid { spacing: Vec2::new(75.0, 75.0), rotation_rads: PI * 0.25 },
    Name::new("Feature zone"),
)]
pub struct FeatureZone;

fn spawn_feature_zone(mut commands: Commands) {
    commands
        .spawn((FeatureZone, Transform::from_xyz(0., 50., 0.)))
        .observe(validate_balls)
        .observe(invalidate_balls);
}

/// Marks a [`PlayerBall`] as a valid target for constructing a new feature.
#[derive(Component)]
pub struct ValidZone;

fn validate_balls(
    trigger: Trigger<OnCollisionStart>,
    mut commands: Commands,
    invalid_balls: Query<Entity, (With<PlayerBall>, Without<ValidZone>)>,
) {
    if let Ok(entity) = invalid_balls.get(trigger.collider) {
        commands.entity(entity).insert(ValidZone);
    }
}

fn invalidate_balls(
    trigger: Trigger<OnCollisionEnd>,
    mut commands: Commands,
    valid_balls: Query<Entity, (With<PlayerBall>, With<ValidZone>)>,
) {
    if let Ok(entity) = valid_balls.get(trigger.collider) {
        commands.entity(entity).remove::<ValidZone>();
    }
}

/// The base amount of points a feature should give.
#[derive(Clone, Component)]
pub struct Points(pub usize);

/// Temporarily disable the effect of a feature collision for a [`Ball`].
#[derive(Component)]
pub struct FeatureCooldown<T: 'static> {
    timer: Timer,
    _feature: PhantomData<fn() -> T>,
}

impl<T> FeatureCooldown<T> {
    pub fn from_seconds(duration: f32) -> Self {
        Self {
            timer: Timer::from_seconds(duration, TimerMode::Once),
            _feature: PhantomData,
        }
    }
}

fn feature_cooldown<T>(
    mut commands: Commands,
    time: Res<Time>,
    mut cooldowns: Query<(Entity, &mut FeatureCooldown<T>)>,
) {
    for (entity, mut cooldown) in cooldowns.iter_mut() {
        cooldown.timer.tick(time.delta());
        if cooldown.timer.finished() {
            commands.entity(entity).remove::<FeatureCooldown<T>>();
        }
    }
}

/// The number of bonks before the feature despawns.
#[derive(Clone, Component)]
#[require(RigidBody::Kinematic, CollisionEventsEnabled)]
enum Bonks {
    Limited(usize),
    #[allow(unused)]
    Reloading {
        max: usize,
        current: usize,
    },
    Unlimited,
}

fn bonks(
    trigger: Trigger<OnCollisionStart>,
    mut bonks: Query<&mut Bonks>,
    mut writer: EventWriter<BonksReload>,
) {
    if let Ok(mut bonks) = bonks.get_mut(trigger.target()) {
        match bonks.as_mut() {
            Bonks::Limited(bonks) => {
                *bonks = bonks.saturating_sub(1);
            }
            Bonks::Reloading { max, current } => {
                *current = current.saturating_sub(1);
                if *current == 0 {
                    *current = *max;
                    writer.write(BonksReload(trigger.target()));
                }
            }
            _ => {}
        }
    }
}

fn despawn_empty_bonks(mut commands: Commands, bonks: Query<(Entity, &Bonks)>) {
    for (entity, _) in bonks
        .iter()
        .filter(|(_, bonks)| matches!(bonks, Bonks::Limited(bonks) if *bonks == 0))
    {
        commands.entity(entity).despawn();
    }
}

/// [`Bonks::Reloading`] reaches 0.
#[derive(Event)]
#[allow(unused)]
struct BonksReload(Entity);

/// The factor applied to the impulse generated by a bonk.
#[derive(Clone, Component)]
struct BonkImpulse(f32);

fn feature_bonk(
    trigger: Trigger<OnCollisionStart>,
    mut bonk_writer: EventWriter<FeatureBonk>,
    mut point_writer: EventWriter<PointEvent>,
    features: Query<(&GlobalTransform, &Points), With<Feature>>,
    balls: Query<&BallComponents>,
    collider: Query<Option<&PaddleRestMult>>,
) {
    let Ok((transform, Points(points))) = features.get(trigger.target()) else {
        return;
    };

    if balls.get(trigger.collider).is_err() {
        return;
    }

    if *points == 0 {
        return;
    }

    let mut points = *points as f32;
    if let Ok(Some(paddle_mult)) = collider.get(trigger.collider) {
        points *= 1. + paddle_mult.0;
    }

    bonk_writer.write(FeatureBonk {
        feature: trigger.target(),
        ball: trigger.collider,
    });
    point_writer.write(PointEvent {
        position: transform.translation().xy(),
        points: BigPoints::new((points as i32).max(1)),
    });
}

#[derive(Component)]
struct ImpulseGizmo {
    impulse: Vec2,
    timer: Timer,
}

fn debug_impulse(
    mut impulses: Query<(Entity, &GlobalTransform, &mut ImpulseGizmo)>,
    mut gizmos: Gizmos,
    mut commands: Commands,
    time: Res<Time>,
) {
    let delta = time.delta();
    for (entity, position, mut impulse) in impulses.iter_mut() {
        let translation = position.translation().xy();
        let scale_factor = 5e-4;

        gizmos.arrow_2d(
            translation,
            translation + impulse.impulse * scale_factor,
            Color::WHITE,
        );

        if impulse.timer.tick(delta).just_finished() {
            commands.entity(entity).despawn();
        }
    }
}

fn bonk_bounce(
    trigger: Trigger<OnCollisionStart>,
    features: Query<(&GlobalTransform, &BonkImpulse), With<Feature>>,
    mut balls: Query<(&GlobalTransform, &mut ExternalImpulse), Or<(With<Ball>, With<PlayerBall>)>>,
    mut commands: Commands,
) {
    match (
        features.get(trigger.target()),
        balls.get_mut(trigger.collider),
    ) {
        (Ok((transform, mult)), Ok((ball_transform, mut bonk))) => {
            let ball_trans = ball_transform.translation().xy();
            let feature_trans = transform.translation().xy();

            let impulse = (ball_trans - feature_trans).normalize_or_zero() * 38_000. * mult.0;
            bonk.apply_impulse(impulse);

            #[cfg(debug_assertions)]
            commands.spawn((
                ImpulseGizmo {
                    impulse,
                    timer: Timer::new(Duration::from_secs(2), TimerMode::Once),
                },
                ball_transform.compute_transform(),
            ));
        }
        _ => {}
    }
}
